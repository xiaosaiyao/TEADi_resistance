#!/usr/bin/env Rscript

# Function that runs various standard qc analyses for an archr project.
# Author: Julien Tremblay - julien.tremblay@contractors.roche.com
# Roche/Genentech

archr_generate_ordinations <- function(indir=NULL, num_threads=num_threads, by_library=FALSE, exclude_sample=NULL) {

    #setwd("/gstore/project/tead/scMultiome/NGS4467_pilot_JT/analysis/")
    #indir = "./output/archr/"
    #num_threads = 4
    #by_library=FALSE
    #num_threads = as.numeric(num_threads)
    
    if(!isTRUE(by_library) & !isFALSE(by_library)){
        stop("-l arg (by_library) has to be TRUE or FALSE. Provided value: ", by_library)
    }
    
    if(is.null(indir)){ # TODO check if dir
        stop("an indir has to be included")
    }
    
    if(is.null(num_threads)){
        stop("num_threads=<positive_integer> has to be incuded.")
    }else{
        if(!is.numeric(num_threads)){
            stop("num_threads has to be numeric.")
        }
    }
    
    if(by_library == TRUE){
        my_width = 20
    }else{
        my_width = 11
    }
    
    library(ArchR)
    library(MASS)
    library(viridis)
    library(scales)
    library(ggpubr)
    library(BSgenome.Hsapiens.Genentech.GRCh38)
    source("./tools/R/lib/utils.R")
    
    archr_proj = ArchR::loadArchRProject(indir)
    
    # Manage the size of the plot integrating the legend size
    number_of_samples = length(unique(getCellColData(archr_proj)[["Treatment_HTO"]]))
    one_row = 0.5
    number_of_rows = ceiling(number_of_samples / 3)
    row_padding = number_of_rows * 0.15

    message("Generating UMAP ATAC")
    # IterativeLSI for ATAC already generated by init.archR(?). Clusters_ATAC in getCellColData() already there.
    archr_proj = addUMAP(archr_proj, reducedDims='IterativeLSI_ATAC', name='UMAP_ATAC', seed=2, force=TRUE, threads=num_threads)
    
    message("Generating UMAP TileMatrix")
    # add reduced dims TileMatrix
    archr_proj = addIterativeLSI(archr_proj, useMatrix='TileMatrix', name='IterativeLSI_TileMatrix', seed=2, force=TRUE, threads=num_threads)
    archr_proj = addClusters(archr_proj, reducedDims='IterativeLSI_TileMatrix', name='Clusters_TileMatrix', seed=2, prefix='C_TileMatrix', force=TRUE, threads=num_threads)
    archr_proj = addUMAP(archr_proj, reducedDims='IterativeLSI_TileMatrix', name='UMAP_TileMatrix', seed=2, force=TRUE, threads=num_threads)

    message("Generating UMAP GeneExpressionMatrix")
    # add reduced dims GeneExpressionMatrix
    archr_proj = addIterativeLSI(archr_proj, useMatrix='GeneExpressionMatrix', name='IterativeLSI_GeneExpressionMatrix', seed=2, force=TRUE, threads=num_threads)
    archr_proj = addClusters(archr_proj, reducedDims='IterativeLSI_GeneExpressionMatrix', name='Clusters_GeneExpressionMatrix', seed=2, force=TRUE, prefix='C_GeneExpressionMatrix', threads=num_threads)
    archr_proj = addUMAP(archr_proj, reducedDims='IterativeLSI_GeneExpressionMatrix', name='UMAP_GeneExpressionMatrix', seed=2, force=TRUE, threads=num_threads)
    
    message("Generating combined UMAPs")
    # Combine both dimensionalities, add cluster to resulting combined dim and add umap
    archr_proj = addCombinedDims(archr_proj, reducedDims=c('IterativeLSI_TileMatrix', 'IterativeLSI_GeneExpressionMatrix'), name='IterativeLSI_Combined')
    archr_proj = addClusters(archr_proj, reducedDims='IterativeLSI_Combined', name='Clusters_Combined', seed=2, force=TRUE, prefix='C_Combined', threads=num_threads)
    archr_proj = addUMAP(archr_proj, reducedDims='IterativeLSI_Combined', name='UMAP_Combined', seed=2, force=TRUE, threads=num_threads)
    
    # Generate UMAP plots
    embeddings = c("TileMatrix", "GeneExpressionMatrix", "Combined", "ATAC")
    ps_umap = list()
    for(i in 1:length(embeddings)){
        embed = NULL
        embedding = embeddings[i]
        embed = getEmbedding(archr_proj, embedding=paste0("UMAP_", embedding))
        embed = cbind(embed, getCellColData(archr_proj, select=c("Treatment", "HTO", "Treatment_HTO", "Treatment_library", "library")))
        colnames(embed)[1] = "UMAP_dim_1"
        colnames(embed)[2] = "UMAP_dim_2"
        
        p = NULL; p = ggplot(embed, aes(x=UMAP_dim_1, y=UMAP_dim_2, color=Treatment_HTO)) +
            geom_point(size=0.3) +
            scale_color_manual(values=vColors) +
            xlab(paste0("UMAP dim 1")) +
            ylab(paste0("UMAP dim 2")) +
            ggtitle(paste0("Iterative ", embedding, " UMAP")) +
            guides(color = guide_legend(override.aes=list(size=1.5))) + guides(fill=guide_legend(ncol=3)) + #guides(fill = guide_legend(override.aes = list(size=4))) +  
            theme_minimal() + theme(
                panel.border=element_rect(fill=NA, linetype="solid", colour = "black", linewidth=0.5), axis.text.x=element_text(angle=90), axis.title=element_text(size=10),
                strip.text.y=element_text(angle=0), legend.position="bottom", legend.title=element_blank(), legend.key.size=unit(0.1, "cm"), 
                plot.title=element_text(size=10))
        if(by_library == TRUE){
            p = p + facet_wrap(. ~ library)
        }
        ps_umap[[i]] = p
    }
    
    figure_umap = do.call("grid_arrange_shared_legend", c(ps_umap, ncol=2, nrow=2, position="bottom"))
    figure_umap2 = annotate_figure(figure_umap, bottom=text_grob(unique(getCellColData(archr_proj, select="Sample")[,1]), size=9))
    ggsave(paste0(indir, "/qc/umaps.png"), plot=figure_umap2, device="png", height=(19.5 + row_padding), width=20, units="cm")
    ggsave(paste0(indir, "/qc/umaps.pdf"), plot=figure_umap2, device="pdf", height=(19.5 + row_padding), width=20, units="cm")
    
    # Add tSNE embeddings
    message("Generating t-SNE ordinations")
    archr_proj = addTSNE(archr_proj, reducedDims='IterativeLSI_TileMatrix', name='TSNE_TileMatrix', perplexity=30, seed=2, force=TRUE, threads=num_threads)
    archr_proj = addTSNE(archr_proj, reducedDims='IterativeLSI_GeneExpressionMatrix', name='TSNE_GeneExpressionMatrix', perplexity=30, seed=2, force=TRUE, threads=num_threads)
    archr_proj = addTSNE(archr_proj, reducedDims='IterativeLSI_Combined', name='TSNE_Combined', perplexity=30, seed=2, force=TRUE, threads=num_threads)
    archr_proj = addTSNE(archr_proj, reducedDims='IterativeLSI_ATAC', name='TSNE_ATAC', perplexity=30, seed=2, force=TRUE, threads=num_threads)
    
    ps_tsne = list()
    for(i in 1:length(embeddings)){
        embed = NULL
        embedding = embeddings[i]
        embed = getEmbedding(archr_proj, embedding=paste0("TSNE_", embedding))
        embed = cbind(embed, getCellColData(archr_proj, select=c("Treatment", "HTO", "Treatment_HTO", "Treatment_library", "library")))
        colnames(embed)[1] = "TSNE_dim_1"
        colnames(embed)[2] = "TSNE_dim_2"
        
        p = NULL; p = ggplot(embed, aes(x=TSNE_dim_1, y=TSNE_dim_2, color=Treatment_HTO)) +
            geom_point(size=0.3) +
            scale_color_manual(values=vColors) +
            ggtitle(paste0("Iterative ", embedding, " t-SNE")) +
            xlab(paste0("t-SNE dim 1")) +
            ylab(paste0("t-SNE dim 2")) +
            guides(color = guide_legend(override.aes = list(size=1.5))) + guides(fill=guide_legend(ncol=1)) + #guides(fill = guide_legend(override.aes = list(size=4))) +  
            theme_minimal() + theme(
                panel.border=element_rect(fill=NA, linetype="solid", colour = "black", linewidth=0.5), axis.text.x=element_text(angle=90), axis.title=element_text(size=10),
                strip.text.y=element_text(angle=0), legend.position="bottom", legend.title=element_blank(), legend.key.size=unit(0.1, "cm"), 
                plot.title=element_text(size=10))
        if(by_library == TRUE){
            p = facet_wrap(. ~ library)
        }
        ps_tsne[[i]] = p
    }
    figure_tsne = do.call("grid_arrange_shared_legend", c(ps_tsne, ncol=2, nrow=2, position="bottom"))
    figure_tsne2 = annotate_figure(figure_tsne, bottom=text_grob(unique(getCellColData(archr_proj, select="Sample")[,1]), size=9))
    ggsave(paste0(indir, "/qc/tsne.png"), plot=figure_tsne2, device="png", height=(19.5 + row_padding), width=20, units="cm")
    ggsave(paste0(indir, "/qc/tsne.pdf"), plot=figure_tsne2, device="pdf", height=(19.5 + row_padding), width=20, units="cm")
    
    # Plot doublets
    types = c("UMAP", "TSNE")
    ps_doublets = list()
    for(i in 1:length(types)){
        embed = NULL
        type = types[i]
        type2 = NULL
        if(type == "UMAP"){
            type2 = "UMAP"
        }else if(type == "TSNE"){
            type2 = "t-SNE"
        }else{
            stop("Something wrong with type / type2 variable.")
        }
        embed = getEmbedding(archr_proj, embedding=paste0(type, "_Combined"))
        embed = cbind(embed, getCellColData(archr_proj, select=c("Treatment", "HTO", "Treatment_HTO", "Treatment_library", "library", "DoubletEnrichment")))
        colnames(embed)[1] = paste0("dim_1")
        colnames(embed)[2] = paste0("dim_2")
        
        p = NULL; p = ggplot(embed, aes(x=dim_1, y=dim_2, color=DoubletEnrichment)) +
            geom_point(size=0.75) +
            scale_colour_gradient2() + 
            ggtitle(paste0("Iterative", "Combined ", type2)) +
            xlab(paste0(type2, " dim 1")) +
            ylab(paste0(type2, " dim 2")) +
            guides(color = guide_legend(override.aes = list(linewidth=4))) + 
            theme_minimal() + theme(
                panel.border=element_rect(fill=NA, linetype="solid", colour = "black", linewidth=0.5), axis.text.x=element_text(angle=90), axis.title=element_text(size=10),
                strip.text.y=element_text(angle=0), legend.position="bottom", legend.title=element_blank(), legend.key.size=unit(0.1, "cm"), 
                plot.title=element_text(size=10))
        if(by_library == TRUE){
            p = p + facet_wrap(. ~ library)
        }
        ps_doublets[[i]] = p
    }
    if(by_library == TRUE){
        figure_doublets = do.call("grid_arrange_shared_legend", c(ps_doublets, ncol=2, nrow=2, position="bottom"))
        figure_doublets2 = annotate_figure(figure_doublets, bottom =text_grob(paste0("Doublet score was computed with ArchR which itself uses demuxlet (github.com/statgen/demuxlet).", unique(getCellColData(archr_proj, select="Sample")[,1])), size=9))
        ggsave(paste0(indir, "/qc/doublets.png"), plot=figure_doublets2, device="png", height=24, width=my_width, units="cm")
        ggsave(paste0(indir, "/qc/doublets.pdf"), plot=figure_doublets2, device="pdf", height=24, width=my_width, units="cm")
    }else{
        figure_doublets = do.call("grid_arrange_shared_legend", c(ps_doublets, ncol=2, nrow=1, position="bottom"))
        figure_doublets2 = annotate_figure(figure_doublets, bottom =text_grob(paste0("Doublet score was computed with ArchR which itself uses demuxlet (github.com/statgen/demuxlet). ", unique(getCellColData(archr_proj, select="Sample")[,1])), size=9))
        ggsave(paste0(indir, "/qc/doublets.png"), plot=figure_doublets2, device="png", height=12, width=my_width+10, units="cm")
        ggsave(paste0(indir, "/qc/doublets.pdf"), plot=figure_doublets2, device="pdf", height=12, width=my_width+10, units="cm")
    }
        
    saveArchRProject(archr_proj, overwrite=TRUE, logFile=createLogFile("saveArchRProject"), threads=1)
    message("archr_generate_ordinations.R completed!")
}

is.defined <- function(sym) {
    sym <- deparse(substitute(sym))
    env <- parent.frame()
    exists(sym, env)
}

usage=function(errM) {
    cat("\nUsage : Rscript my_script_name.R [option] <Value>\n")
    cat("       -i        : indir containing the archR data structure.")
    cat("       -n        : num_threads <int>")
    cat("       -l        : plot ordinations separately for each sequencing library. TRUE or FALSE. Default=FALSE.")
    cat("       -e        : If one or many samples are to be excluded ex: SAM24416357,SAM24416358 (seperated by a ,). Default=NULL.")
}

ARG = commandArgs(trailingOnly = T)

if(length(ARG) < 2) {
    usage("missing arguments")
}

## get arg variables
for (i in 1:length(ARG)) {
    if (ARG[i] == "-i"){
        indir=ARG[i+1]
    }else if(ARG[i] == "-n") {
        num_threads=ARG[i+1]
    }else if(ARG[i] == "-l") {
        by_library=ARG[i+1]
    }else if(ARG[i] == "-e") {
        exclude_sample=ARG[i+1]
    }
}

if(!is.defined(by_library)){ by_library = FALSE }
if(!is.defined(exclude_sample)){ exclude_sample = NULL }

archr_generate_ordinations(indir=indir, num_threads=num_threads, by_library=by_library, exclude_sample=exclude_sample)
